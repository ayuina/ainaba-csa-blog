---
layout: default
title: Azure Artifacts を使用した Nuget パッケージの管理
---

## はじめに

Azure Artifacts をちゃんと使ったことが無かったので検証した際の備忘録です。
下記は大まかなワークフローというか、やりたいことを整理するための図になります。

![パッケージ管理の全体像](./images/package-management-workflow.png)

大きく共有ライブラリや便利ツールなどの「他の人に使ってもらう」ための部品となるパッケージを開発する側と、それらの部品を利用して実際にエンドユーザーに使ってもらうアプリケーション開発側に大きく分かれます。
これらの２つの立場で開発のライフサイクルが大きく異なるため、そのパッケージを受け渡すための中間地点となるリポジトリが必要になってくるわけです。

なお Azure Artifacts は様々種類の言語とパッケージを扱えるのですが、以下ではプログラミング言語は C# (.NET Core)、パッケージ形式は Nuget を題材にしています。

### ちょっと個人的な昔話（組織内における共通部品の管理について）

古来からのやり方ですと、自分が C# で作った「部品」はソースコードとして丸ごとコピーしてもらう、ビルド済みバイナリ形式であるアセンブリ（通常は dll）をコピーしてもらうことが多かったかと思います。
前者の方法では部品としての完全性が保てず、利用側で改変しやすいために亜種が発生しやすく、結果的にメンテナンスが困難になりやすいため、後者のバイナリでの配布形式をとられていたことが多いのではないでしょうか。
ただバイナリ形式の場合でも、配布の方式がまちまちであること、利用側へのアップデートの伝達が困難であること、その結果として古代のバージョンが延々と使われ続けてしまう、などといった問題が往々にして発生しました。

なんだかんだいって「共有フォルダに置かれた DLL を勝手に使っていくスタイル」が蔓延っていたなあなどと懐かしく思うわけです。
組織内でのパッケージ管理の仕組みをちゃんと運用すれば良いわけですが、その仕組み自体をだれがサポート・保守・運用するのさ？ ということで誰もやらないパターンでした。
が、Azure DevOps などの SaaS サービスを使ってしまえばその問題は発生しにくくなりますので、改めて勉強してみようと思った次第です。

## パッケージの作成と公開

まずローカル開発環境で Nuget パッケージを作る方法です。前提として「共有したい部品」である DLL が既にあることを前提とします。

### 共通部品クラスライブラリの作成

が、適当なものが無い場合は下記のようなコマンドで C# のクラスライブラリプロジェクトを作ってしまいましょう。ポータビリティの高い .NET Standard にしてみます。

```pwsh
> dotnet new classlib --name Ayuina.Samples.Utility --framework netstandard2.0
```

出来上がったソースコードにロジックを追加します。まじめに作る気はないので以下のような感じで良いでしょうか。

```csharp
using System;

namespace Ayuina.Samples.Utility
{
    public class Class1
    {
        public static string Hello(string name)
        {
            return $"Hello {name} !";
        }
    }
}
```

ではビルドしてアセンブリを作成します。ビルドに成功したら生成物を確認してみましょう。拡張子 `dll` のファイルができていればとりあえず良しとします。

```pwsh
> dotnet build
> dir .\bin\Debug\netstandard2.0

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----       2019/05/15     17:52           1465 Ayuina.Samples.Utility.deps.json
-a----       2019/05/15     17:52           4096 Ayuina.Samples.Utility.dll
-a----       2019/05/15     17:52            512 Ayuina.Samples.Utility.pdb
```

### パッケージを生成する

ではシンプルにこのまま Nuget パッケージを生成してみます。プロジェクトルートフォルダ（csproj ファイルがあるフォルダ）にて下記のコマンドを実行してみます。

```pwsh
dotent pack
```

成功するとビルド出力ディレクトリに拡張子 nupkg のファイルが出来ていると思います。

```pwsh
> dir .\bin\Debug

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----       2019/05/15     17:52                netstandard2.0
-a----       2019/05/15     17:57           3461 Ayuina.Samples.Utility.1.0.0.nupkg
```

### パッケージの中身を確認する

これで出来上がりなのですが、中身を見てみましょう。この `nupkg` は ZIP 形式のファイルの拡張子を変えただけなので、ZIP を解凍できるツールがあれば中身を見ることができます。

```pwsh
> cp .\bin\Debug\Ayuina.Samples.Utility.1.0.0.nupkg .\bin\Debug\Ayuina.Samples.Utility.1.0.0.zip
> Expand-Archive .\bin\Debug\Ayuina.Samples.Utility.1.0.0.zip
```

中身を見てみるとごちゃごちゃっと入っていますが、ポイントは以下の2点でしょうか。
- lib > target_framework 配下に共有したいアセンブリが格納されている
- ルートに nuspec というファイルが生成され、中にはバージョン番号など管理用のメタデータが含まれている

![nupkgの中身](./images/inside-nupkg.png)

この `nuspec` はプロジェクトの出力ディレクトリである `bin` ではなく、中間生成ファイルなどが格納される `obj` にも同じものが生成されています。 
 `nuspec` はパッケージの仕様を決めているマニフェストファイルなのですが、ここに記載された情報はプロジェクトファイル `csproj` から自動的に生成されています。
 逆に言えば、ちゃんとしたメタデータを記載したいならば `csproj` を編集する必要があることになります。



## パッケージの自動リリースパイプライン

## 開発環境でのパッケージの利用

## アプリケーションのリリースパイプラインでの利用


### 参考情報

- [NuGet](https://docs.microsoft.com/ja-jp/nuget/what-is-nuget)
